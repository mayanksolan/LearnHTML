Array

const arr1 = ['a', 'b', 'c', 'x'];
const arr2 = ['m', 'n', 'x', 'y', 'r'];

1. const set1 = new Set();
	This is used to store different unique elements to the set1 and is used to find duplicates
	set1.add(arr1[i]) -> is used to add non duplicate element
	set1.has(arr2[i])	-> is used to check if the element already exist or not
	
2. Adding array to object
	let tally={}; To add array to object, loop through each element in array to add like below - 
	map[arr1[i]]=true; -> this will take the property as array value and the value is defaulted to true
	
	true
	
3. arr1.some() -> this is used to check if arr1 matches the value passed in ()
	Like arr1.some(item => arr2.includes(item)) - here arr1 each item is being checked in arr2 and return true is done if match found
	
4. str.split('') - this functions splits the string in the form of array

5. str.split('').reverse() - this function reverses the split string array

6. str.split('').reverse().join(''); - this function joins the reversed split str array

7. unshift() and shift() operate in the same way as push() and pop(), except that they add/remove values to the BEGINNING of an array.

8. slice() is used to copy different portions of an array, e.g.: 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	var citrus = fruits.slice(1, 3); …leads to… 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	var citrus = ['Orange', 'Lemon'];
	
9. splice() To Remove an element, use this syntax: 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	fruits.splice(1, 2); …leads to… 
	var fruits = ['Banana', 'Apple', 'Mango'];
	
	Add
	var fruits = ['Banana', 'Apple', 'Mango']; 
	fruits.splice(1, 0, 'Orange', 'Lemon'); …leads to… 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
	
10. var colors = ['red', 'orange', 'yellow', 'green']; 
	colors.forEach(function(color) { // "color" is a placeholder to represent a 
		console.log(color); 		 // singular instance of any given element in 
	}); 							 // the collection; call it whatever you want
	
11. Higher Order Functions - 

	setInterval(function() { // code that you want to run every second; }, 1000);
	
12 Undefined vs Undeclared - undefined variables are those that are not assigned any value but declared in the program. if we try to read the value, undefined is displayed
								var a;
								alert(a);	// this will output undefined
							undeclared values are those that are not declared in the program. If we try to read their values it will give runtime error.
								alert("hello"+"--"+b);	//	Uncaught ReferenceError: b is not defined
								
13. Coercion in Javascript
	let a=4; let b="4";
	console.log(a+b);	// "44"
	console.log(b+a);	// "44"
	Rule for implicit coercion: Comparison by using == does implicit type conversion under the hood. And rules for implicit coercion are as follows-
	->	If both operands are same type use ===
	->	undefined == null
	->	If one operands is string another is number, convert string to number
	->	If one is boolean and another is non-boolean, convert boolean to number and then perform comparison
	->	While comparing a string or number to an object, try to convert the object to a primitive type and then try to compare
	
	a. console.log("5" - 5);	//	returns 0
	b. console.log("5" + 5);	//	returns 55
	c. const giveType = typeof 5	// console log returns number
	d. const giveType = typeof "5"	// console log returns string
	e. const giveType = typeof {}	// console log returns object
	f. const adder = true + 5;		// console log returns 6
	g. const adder = false + 5;		// console log returns 5
	
	Values that interpret as false
	a. false
	b. 0
	c. ""
	d. null
	e. undefined
	f. NaN
	
	Everything else is true
	
	var a = {a: 1};
	var b = {a: 1};
	a == b //false
	a === b //false
	
	
	Some other cases
	true%1	//	0
	''%1	//	0
	[]==true	//	false	//Since left and right side of the equality are two different types, JavaScript can't compare them directly . Hence, under the hood, JavaScript will 	 convert them to compare. first right side of the equality will be cooereced to a number and number of true would be 1.
							//After that, JavaScript implementation will try to convert [] by usingtoPrimitive (of JavaScript implementation). since [].valueOf is not primitive will use toString and will get ""
							//Now you are comparing "" == 1 and still left and right is not same type. Hence left side will be converted again to a number and empty string will be 0.
	
	
14. Object Equality
	
	var e = {a:1,b:2,c:3};
	var eProps = Object.getOwnPropertyNames(e);
	console.log(eProps);	//	(3) ["a", "b", "c"]
	
15 Math.max to find max in array
	let arr = [3,6,1,7,2,9,11,5];
	function getMax(arr)	{
		return Math.max.apply(null, arr);
	}
	getMax(arr);	// 11
	
16	= operator has associativity from right to left means - 
	let a = 6; 	\\ this means the value defined on the right is assigned to left variable a
	+, -, /, * operators have associativity from left to right (it follows bodmas rule) means -
	console.log(+"3"+2+6);	// prints 11 because it starts checking from left, + opeartor comes, so it thinks this is addition operation so converts 3 to a number and move on
	console.log("3"+2+6);	// prints 326	because it encounters " so it thinks this is string operation so concatenates
	let a=3, b=8, c=6; 	console.log(a+b+"Mayank"+b+c)	// prints 11Mayank86, here initially it starts with a which is number so it adds a and b, then it tries adding Mayank which is 
														// string so JS says okay string is here so lets concatenate and further ahead aslo it considers it as string hence 11Mayank86
	
17.	IIFE (Immediately Invoked Function Expression)

18. Closures in JavaScript - 
	a. 	Variables - Any function where you are using a variable from outise the scope are actually closures
		Example - Variables	-	var passed = 3;
								var addTo = function() {	var inner = 2;	return passed+inner;	}
								console.log(addTo());	//returns 5
	b. Closures are just functions which preserve data
		var addTo = function(passed){    
			var add = function(inner){
			return passed + inner;  
			};    
		return add;   
		};
		var addThree = new addTo(3);
		var addFour = new addTo(4);
		console.dir(addThree(1));
		console.dir(addFour(1));
		// returns  4 then 5
	
19.	Promises - Makes sure if the conditions are matched then do the next job
	let p = new Promise((resolve, reject) => {
		let a=1+1;
		if(a==2) {
			resolve("Success");
		} else {
			reject("Failed");
		}
	});
	
	p.then((message) => {
		console.log("This is in the then "+message);
	}).catch((message) => {
		console.log("This is in the catch "+message);
	});
	
	// Output - This is in the then Success
	
	
	Promises All - Returns the output message when all are completed
	Below are three differencet promises
	const recordVideoOne = new Promise((resolve, reject) => {
	  resolve('Video 1 Recorded')
	})

	const recordVideoTwo = new Promise((resolve, reject) => {
	  resolve('Video 2 Recorded')
	})

	const recordVideoThree = new Promise((resolve, reject) => {
	  resolve('Video 3 Recorded')
	})
	
	Promise.all([
	  recordVideoOne,
	  recordVideoTwo,
	  recordVideoThree
	]).then(messages => {
	  console.log(messages)
	})
	
	Promises Race - Returns the first function output as soon as anyone of them is completed
	Promise.race([
	  recordVideoOne,
	  recordVideoTwo,
	  recordVideoThree
	]).then(message => {
	  console.log(message)
	})
	
	
	
	
	
Rapid Fire	-

1. 	Question: What is typeof [], typeof arguments
	Answer: Object. Actually Array is derived from Object. If you want to check array use Array.isArray(arr)
					arguments are array like but not array. it has length, can access by index but can't push pop, etc.
					
2.	What is the value of 4+3+2+"1"
	"91"
	
3. 	var ab = (2,3,5);
	console.log(ab);	// 5	//The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand. ref: MDN
	
4. 	!'bang' returns false
	!!'bang' returns true
	
5. 	Question: What is the value of Math.max([2,3,4,5]);
	Answer: NaN
	
6. 	Question:null == undefined
	Answer: true
	
7. 	Question: Does JavaScript pass parameter by value or by reference?
	Answer: Primitive type (string, number, etc.) are passed by value and objects are passed by reference.
	
8. 	(function(){
		var a = b = 3;
	})();
	console.log("a defined? " + (typeof a !== 'undefined'));
	console.log("b defined? " + (typeof b !== 'undefined'));
	
	Answer:	a defined? false	// because var a=b, and b=3.... so a is undefined and b defined value of 3
			b defined? true		// because like above
			
9.	var myObject = {
		foo: "bar",
		func: function() {
			var self = this;
			console.log("outer func:  this.foo = " + this.foo);
			console.log("outer func:  self.foo = " + self.foo);
			(function() {
				console.log("inner func:  this.foo = " + this.foo);
				console.log("inner func:  self.foo = " + self.foo);
			}());
		}
	};
	myObject.func();
	
	Answer:	outer func:  this.foo = bar
			outer func:  self.foo = bar
			inner func:  this.foo = undefined
			inner func:  self.foo = bar