Parameters are variables listed as a part of the function definition.
Arguments are values passed to the function when it is invoked.

this is the object that the function is a property of
https://www.udemy.com/course/advanced-javascript-concepts/learn/lecture/13772916#questions
const obj = {
	name:"Billy",
	sing() {
		return "lalala " + this.name
	},
	singAgain() {
		return this.sing() + "!";
	}
}
obj.sing();
obj.singAgain();

this refers to what is present on left side of the dot where the function is called

In javascript our lexical scope that is available data variables where the function was
defined determines are available variables not where the function is called which is called Dynamic


========================JS this Keyword -

https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c
In a method, this refers to the owner object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.
In an event, this refers to the element that received the event.
Methods like call(), and apply() can refer this to any object.

================CAB -> Call, Apply, Bind==========
https://www.codementor.io/niladrisekhardutta/how-to-call-apply-and-bind-in-javascript-8i1jca6jp
	Call - The first parameter in call() method sets the "this" value, which is the object, on which the function is invoked upon. The rest of the parameters are the arguments to the actual function.
	Apply - The apply() is similar to call() only difference being method takes arguments as an array.
	Bind - we are returning a bound function with the context which will be invoked later.

Uses - You can use call()/apply() to invoke the function immediately. bind() returns a bound function that, when executed later, will have the correct context ("this") for calling the original function. So bind() can be used when the function needs to be called later in certain events when it's useful.
	
Call - 
//Demo with javascript .call()
var obj = {name:"Niladri"};
var greeting = function(a,b,c){
    return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};
console.log(greeting.call(obj,"Newtown","KOLKATA","WB"));
// returns output as welcome Niladri to Newtown KOLKATA in WB

Apply - 
//Demo with javascript .apply()
var obj = {name:"Niladri"};
var greeting = function(a,b,c){
    return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};
// array of arguments to the actual function
var args = ["Newtown","KOLKATA","WB"];  
console.log("Output using .apply() below ")
console.log(greeting.apply(obj,args));
/* The output will be 
  Output using .apply() below
 welcome Niladri to Newtown KOLKATA in WB */

Bind - 
var obj = {name:"Niladri"};

var greeting = function(a,b,c){
    return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};

//creates a bound function that has same body and parameters 
var bound = greeting.bind(obj, 'Newtown'); 	// we can provide 0 or more arguments we want to pass as static here after obj. this is also called function currying

console.dir(bound); ///returns a function
console.log("Output using .bind() below ");
console.log(bound("KOLKATA","WB")); //call the bound function

/* the output will be 
Output using .bind() below
welcome Niladri to Newtown KOLKATA in WB */

=====================JS callback=====================

https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced
Callbacks are a great way to handle something after something else has been completed. By something here we mean a function execution. If we want to execute a function right after the return of some other function, then callbacks can be used.
Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.

Syntax - function add(a, b , callback) -> add() function is called with arguments a, b and callback, callback will be executed just after ending of add() function 

function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
doHomework('math', function() {
  alert('Finished my homework');
});

or or or or

function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
function alertFinished(){
  alert('Finished my homework');
}
doHomework('math', alertFinished);


Array

const arr1 = ['a', 'b', 'c', 'x'];
const arr2 = ['m', 'n', 'x', 'y', 'r'];

1. const set1 = new Set();
	This is used to store different unique elements to the set1 and is used to find duplicates
	set1.add(arr1[i]) -> is used to add non duplicate element
	set1.has(arr2[i])	-> is used to check if the element already exist or not
	
2. Adding array to object
	let tally={}; To add array to object, loop through each element in array to add like below - 
	map[arr1[i]]=true; -> this will take the property as array value and the value is defaulted to true
	
	true
	
3. arr1.some() -> this is used to check if arr1 matches the value passed in ()
	Like arr1.some(item => arr2.includes(item)) - here arr1 each item is being checked in arr2 and return true is done if match found
	
4. str.split('') - this functions splits the string in the form of array

5. str.split('').reverse() - this function reverses the split string array

6. str.split('').reverse().join(''); - this function joins the reversed split str array

7. unshift() and shift() operate in the same way as push() and pop(), except that they add/remove values to the BEGINNING of an array.

8. slice() is used to copy different portions of an array, e.g.: 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	var citrus = fruits.slice(1, 3); …leads to… 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	var citrus = ['Orange', 'Lemon'];
	
9. splice() To Remove an element, use this syntax: 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']; 
	fruits.splice(1, 2); …leads to… 
	var fruits = ['Banana', 'Apple', 'Mango'];
	
	Add
	var fruits = ['Banana', 'Apple', 'Mango']; 
	fruits.splice(1, 0, 'Orange', 'Lemon'); …leads to… 
	var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
	
10. var colors = ['red', 'orange', 'yellow', 'green']; 
	colors.forEach(function(color) { // "color" is a placeholder to represent a 
		console.log(color); 		 // singular instance of any given element in 
	}); 							 // the collection; call it whatever you want
	
11. Higher Order Functions - When you have a function which recieves a function as an argument, it is called as higher order function, e.g. map, filter, reduce
Example 1- 
function add(x, y) {
	return x+y;
}
function higherOrderFunction(a, callback) {
	return callback(5, a);
}
higherOrderFunction(10, add)

this outputs 15

Example 2
setInterval(function() { // code that you want to run every second; }, 1000);

	
12. Undefined vs Undeclared - undefined variables are those that are not assigned any value but declared in the program. if we try to read the value, undefined is displayed
								var a;
								alert(a);	// this will output undefined
							undeclared values are those that are not declared in the program. If we try to read their values it will give runtime error.
								alert("hello"+"--"+b);	//	Uncaught ReferenceError: b is not defined
								
13. Coercion in Javascript
	let a=4; let b="4";
	console.log(a+b);	// "44"
	console.log(b+a);	// "44"
	Rule for implicit coercion: Comparison by using == does implicit type conversion under the hood. And rules for implicit coercion are as follows-
	->	If both operands are same type use ===
	->	undefined == null
	->	If one operands is string another is number, convert string to number
	->	If one is boolean and another is non-boolean, convert boolean to number and then perform comparison
	->	While comparing a string or number to an object, try to convert the object to a primitive type and then try to compare
	
	a. console.log("5" - 5);	//	returns 0
	b. console.log("5" + 5);	//	returns 55
	c. const giveType = typeof 5	// console log returns number
	d. const giveType = typeof "5"	// console log returns string
	e. const giveType = typeof {}	// console log returns object
	f. const adder = true + 5;		// console log returns 6
	g. const adder = false + 5;		// console log returns 5
	
	Values that interpret as false
	a. false
	b. 0
	c. ""
	d. null
	e. undefined
	f. NaN
	
	Everything else is true
	
	var a = {a: 1};
	var b = {a: 1};
	a == b //false
	a === b //false
	
	
	Some other cases
	true%1	//	0
	''%1	//	0
	[]==true	//	false	//Since left and right side of the equality are two different types, JavaScript can't compare them directly . Hence, under the hood, JavaScript will 	 convert them to compare. first right side of the equality will be cooereced to a number and number of true would be 1.
							//After that, JavaScript implementation will try to convert [] by usingtoPrimitive (of JavaScript implementation). since [].valueOf is not primitive will use toString and will get ""
							//Now you are comparing "" == 1 and still left and right is not same type. Hence left side will be converted again to a number and empty string will be 0.
	
	
14. Object Equality
	
	var e = {a:1,b:2,c:3};
	var eProps = Object.getOwnPropertyNames(e);
	console.log(eProps);	//	(3) ["a", "b", "c"]
	
15 Math.max to find max in array
	let arr = [3,6,1,7,2,9,11,5];
	function getMax(arr)	{
		return Math.max.apply(null, arr);
	}
	getMax(arr);	// 11
	
16	= operator has associativity from right to left means - 
	let a = 6; 	\\ this means the value defined on the right is assigned to left variable a
	+, -, /, * operators have associativity from left to right (it follows bodmas rule) means -
	console.log(+"3"+2+6);	// prints 11 because it starts checking from left, + opeartor comes, so it thinks this is addition operation so converts 3 to a number and move on
	console.log("3"+2+6);	// prints 326	because it encounters " so it thinks this is string operation so concatenates
	let a=3, b=8, c=6; 	console.log(a+b+"Mayank"+b+c)	// prints 11Mayank86, here initially it starts with a which is number so it adds a and b, then it tries adding Mayank which is 
														// string so JS says okay string is here so lets concatenate and further ahead aslo it considers it as string hence 11Mayank86
	
17.	IIFE (Immediately Invoked Function Expression)

18. Closures in JavaScript - 
	a. 	Variables - Any function where you are using a variable from outise the scope are actually closures
		Example - Variables	-	var passed = 3;
								var addTo = function() {	var inner = 2;	return passed+inner;	}
								console.log(addTo());	//returns 5
	b. Closures are just functions which preserve data
		var addTo = function(passed){    
			var add = function(inner){
			return passed + inner;  
			};    
		return add;   
		};
		var addThree = new addTo(3);
		var addFour = new addTo(4);
		console.dir(addThree(1));
		console.dir(addFour(1));
		// returns  4 then 5
	
19.	Promises - Makes sure if the conditions are matched then do the next job, (pending, fulfilled or rejected). Promise is creaed inside the function which needs to be called and inside that only it is defined weather to resolve or reject, so that when function is called we can use .then and .catch 
	Example 1
	let p = new Promise((resolve, reject) => {
		let a=1+1;
		if(a==2) {
			resolve("Success");
		} else {
			reject("Failed");
		}
	});
	
	p.then((message) => {
		console.log("This is in the then "+message);
	}).catch((message) => {
		console.log("This is in the catch "+message);
	});
	
	// Output - This is in the then Success
	
	
	
	Promises All - Returns the output message when all are completed
	Below are three differencet promises
	const recordVideoOne = new Promise((resolve, reject) => {
	  resolve('Video 1 Recorded')
	})

	const recordVideoTwo = new Promise((resolve, reject) => {
	  resolve('Video 2 Recorded')
	})

	const recordVideoThree = new Promise((resolve, reject) => {
	  resolve('Video 3 Recorded')
	})
	
	Promise.all([
	  recordVideoOne,
	  recordVideoTwo,
	  recordVideoThree
	]).then(messages => {
	  console.log(messages)
	})
	
	Promises Race - Returns the first function output as soon as anyone of them is completed
	Promise.race([
	  recordVideoOne,
	  recordVideoTwo,
	  recordVideoThree
	]).then(message => {
	  console.log(message)
	})
	
	
	
	
	
Rapid Fire	-

1. 	Question: What is typeof [], typeof arguments
	Answer: Object. Actually Array is derived from Object. If you want to check array use Array.isArray(arr)
					arguments are array like but not array. it has length, can access by index but can't push pop, etc.
					
2.	What is the value of 4+3+2+"1"
	"91"
	
3. 	var ab = (2,3,5);
	console.log(ab);	// 5	//The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand. ref: MDN
	
4. 	!'bang' returns false
	!!'bang' returns true
	
5. 	Question: What is the value of Math.max([2,3,4,5]);
	Answer: NaN
	
6. 	Question:null == undefined
	Answer: true
	
7. 	Question: Does JavaScript pass parameter by value or by reference?
	Answer: Primitive type (string, number, etc.) are passed by value and objects are passed by reference.
	
8. 	(function(){
		var a = b = 3;
	})();
	console.log("a defined? " + (typeof a !== 'undefined'));
	console.log("b defined? " + (typeof b !== 'undefined'));;;;
	
	Answer:	a defined? false	// because var a=b, and b=3.... so a is undefined and b defined value of 3
			b defined? true		// because like above
			
9.	var myObject = {
		foo: "bar",
		func: function() {
			var self = this;
			console.log("outer func:  this.foo = " + this.foo);
			console.log("outer func:  self.foo = " + self.foo);
			(function() {
				console.log("inner func:  this.foo = " + this.foo);
				console.log("inner func:  self.foo = " + self.foo);
			}());
		}
	};
	myObject.func();
	
	Answer:	outer func:  this.foo = bar
			outer func:  self.foo = bar
			inner func:  this.foo = undefined
			inner func:  self.foo = bar
			

10. Interpreter vs Compiler
	Interpreter - reads the code line by line and then tries to solve the problem after converting it to byte code
	Compiler - scans the full code and directly converts it into machine level language, since it takes time but since it sees through full code, it can replace some function calls with the output or full function so to run faster
	
	High level language		->			Byte Code		->		Machine Code
	Javascript code						Interpreter			Compiler
	
	We can use any of the above two to run the program.
	

11. Babel is a Javascript compiler that takes your modern JS code and returns  browser compatible JS (older JS code).
	Typescript is a superset of Javascript that compiles down to Javascript.
	
12. JIT compiler - Combination of Interpreter and compiler

13. V8 Engine of chrome - Steps it takes to run the code - 
	a. JS code is send to the PARSER (Parse the code) and turn it into AST (ABSTRACT SYNTAX TREE)
	b. And code then goes to Interpreter and it spits out bytecode and the program starts running.
	c. Now this bytecode also goes to PROFILER and this checks how we can optimize the code.
	d. If PROFILER sees any code which can be optimised than it sends the code to COMPILER.
	e. The compiler spits out optimised bytecode which then will be used instead of Interpreter bytecode.

14. Memory heap - This simple states that whenever we define a variable and assign a value, it gets stored in the memory heap randomly anywhere.

15. Call Stack - Whenever we create a function and call it, the function gets send to call stack and after the completion of execution call stack removes the function.

16. Memory leak types
	a. Gloabl Variables 
	b. Event Listeners
	c. SetInterval 

17. Execution context
	a. When executing the code, first execution is global and then the functions inside the code
	b. this === window, this will return true

18. Lexical Environment
	a. THis means that whenever we create any function, a new world is created or for say a new lexical environment is created.
	b. Execution context tells us which lexical environment is currently running then it means in which function the code is currently running.
	c. The very first lexical environment is global lexical environment.

19. Hoisting - This term means that when we write any code, then while running the compiler first scans through the whole code and allocates memory to the functions and var declarations. E.g.

console.log("1.....");
console.log(teddy);
console.log(sing());
console.log(sing2());
var teddy = 'bear';
function sing() {	//function declaration
	console.log('Ohh la la la');
}
var sing2 = function() {	//function expression
	console.log('Uhh la la la');
}

	a. Above will print 1....., 
	b. then it prints undefined because compiler scans the code and assigns a memory for variable teddy but with value undefined (P.S. if we use let or const, this functionality does not happen). 
	c. then it prints 'Ohh la la la' beacuse function sing gets memory allocated when compiler scans the code.
	d. then error is print because again var is defined which means undefined. If we just use sing2, then undefined is printed.

Hoisting take aways - 
	a. Variables are partially hoisted
		console.log(one);
		var one = 1;
		var one = 2;	// compiler igores this line since one is already assigned a memory
			// this prints undefined

	b. Functions are fully hoisted 
		a();
		function a() {
  			console.log('hi')
		}
		function a() {
  			console.log('bye')
		}
			// this prints bye

e.g.
function bigBrother(){
  function littleBrother() {
    return 'it is me!';
  }
  return littleBrother();
  function littleBrother() {
    return 'no me!';
  }
}
bigBrother();
// here the output is 'no me!' because when compiler scans the code, inside the lexical context of bigBrother() function, littleBrother function is scanned twice, so in memory no me is hold, now when the program is run then return littleBrother() will display no me output 


20. Function Invocation, Arguments
	a. function marry(p1,p2) {
		console.log(arguments);
		return `${p1} is married to ${p2}`
	}
	marry('Tim', 'Tina')
		// This outputs {0:'Tim', 1:'Tina'}
						Tim is married to Tina
						
21. IIFE - Immediately invoked function expression
	(function() {})()	// this is function expression which is Immediately invoked
	(function(){}())	// this is also correct
	function(){}()	//this is wrong, a function declared cannot be invoked there itself

22. Check if any variable is an array use - 
		Array.isArray([])

23. Primitive types (total 7 types)(number, bigint, string, null, undefined, boolean, symbol) are pass by value
		var a=5; var b=a; b++; clg(a); clg(b)	//5		6
	Non-Primitive types (object, array) are pass by reference

24. Best way to compare two objects
	var user1 = {name : "nerd", org: "dev"};
	var user2 = {name : "nerd", org: "dev"};
	var eq = JSON.stringify(user1) === JSON.stringify(user2);
	alert(eq);